<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RAG Evaluation Dashboard</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@600;700;800&family=Rajdhani:wght@500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

    :root {
      --bg-0: #02071b;
      --bg-1: #061537;
      --bg-2: #0a214a;
      --ink: #dbecff;
      --ink-soft: #8ca8d5;
      --cyan: #4de8ff;
      --mint: #71ffd8;
      --violet: #a67dff;
      --line: #1f3767;
      --card: rgba(9, 20, 54, 0.66);
      --card-strong: rgba(6, 15, 40, 0.84);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Rajdhani', sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 16% 0%, rgba(77, 232, 255, 0.2), transparent 40%),
        radial-gradient(circle at 88% 12%, rgba(166, 125, 255, 0.16), transparent 38%),
        linear-gradient(165deg, var(--bg-0) 0%, var(--bg-1) 46%, var(--bg-2) 100%);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        linear-gradient(rgba(77, 232, 255, 0.07) 1px, transparent 1px),
        linear-gradient(90deg, rgba(77, 232, 255, 0.06) 1px, transparent 1px);
      background-size: 78px 78px;
      mask-image: radial-gradient(circle at 50% 48%, rgba(0, 0, 0, 0.92), rgba(0, 0, 0, 0.35) 72%, transparent 100%);
      z-index: -1;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at 50% -20%, rgba(113, 255, 216, 0.15), transparent 56%);
      z-index: -1;
    }

    .shell {
      max-width: 1220px;
      margin: 0 auto;
      padding: 28px 20px 60px;
    }

    .hero {
      background:
        radial-gradient(circle at 82% 8%, rgba(77, 232, 255, 0.2), transparent 28%),
        linear-gradient(125deg, rgba(8, 17, 46, 0.94) 0%, rgba(8, 29, 72, 0.9) 52%, rgba(27, 20, 70, 0.92) 100%);
      color: var(--ink);
      border: 1px solid rgba(84, 237, 255, 0.45);
      border-radius: 22px;
      padding: 34px;
      position: relative;
      overflow: hidden;
      box-shadow:
        0 18px 40px rgba(4, 10, 28, 0.56),
        0 0 0 1px rgba(77, 232, 255, 0.18) inset,
        0 0 34px rgba(77, 232, 255, 0.24);
    }

    .hero::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 1px solid rgba(166, 125, 255, 0.25);
      transform: scale(0.985);
      pointer-events: none;
    }

    .label {
      display: inline-block;
      letter-spacing: 0.18em;
      font-size: 11px;
      text-transform: uppercase;
      margin-bottom: 14px;
      color: var(--cyan);
      text-shadow: 0 0 12px rgba(77, 232, 255, 0.42);
    }

    h1 {
      margin: 0;
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(34px, 5.8vw, 84px);
      line-height: 0.96;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      background: linear-gradient(90deg, #d9ffff 0%, #87ddff 40%, #d6ccff 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 26px rgba(77, 232, 255, 0.28);
    }

    .manifesto {
      margin-top: 16px;
      max-width: 64ch;
      font-size: 22px;
      line-height: 1.45;
      color: #c3d7fb;
    }

    .meta {
      margin-top: 18px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: #9bb3de;
    }

    .maintainer {
      margin-top: 10px;
      font-size: 20px;
      color: #bbcef5;
    }

    .maintainer strong {
      color: var(--cyan);
      font-weight: 700;
    }

    .topic-tags {
      margin-top: 14px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .topic-tags span {
      border: 1px solid rgba(77, 232, 255, 0.5);
      background: rgba(9, 24, 57, 0.72);
      padding: 5px 12px;
      border-radius: 999px;
      font-size: 13px;
      color: #b8f7ff;
      box-shadow: 0 0 12px rgba(77, 232, 255, 0.2);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(12, minmax(0, 1fr));
      gap: 14px;
      margin-top: 18px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 18px;
      box-shadow:
        0 12px 30px rgba(2, 8, 26, 0.44),
        0 0 20px rgba(77, 232, 255, 0.08);
    }

    .stat {
      grid-column: span 4;
      background:
        linear-gradient(150deg, rgba(9, 22, 58, 0.85), rgba(15, 33, 75, 0.72));
    }

    .stat small {
      display: block;
      font-family: 'JetBrains Mono', monospace;
      text-transform: uppercase;
      color: #90b1de;
      letter-spacing: 0.09em;
      font-size: 11px;
      margin-bottom: 8px;
    }

    .stat strong {
      font-size: clamp(24px, 3vw, 32px);
      color: #e1f3ff;
      text-shadow: 0 0 14px rgba(77, 232, 255, 0.28);
    }

    .section {
      margin-top: 16px;
    }

    .section h2 {
      margin: 0 0 10px;
      font-family: 'Orbitron', sans-serif;
      font-size: 22px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #d8e8ff;
    }

    .table-wrap {
      overflow-x: auto;
      border: 1px solid rgba(77, 232, 255, 0.24);
      border-radius: 14px;
      background: rgba(4, 14, 38, 0.65);
    }

    table {
      border-collapse: collapse;
      min-width: 860px;
      width: 100%;
    }

    thead th {
      text-align: left;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #91d8ff;
      padding: 10px 8px;
      border-bottom: 1px solid rgba(77, 232, 255, 0.4);
      font-family: 'JetBrains Mono', monospace;
      background: rgba(11, 33, 84, 0.7);
    }

    thead th.sortable {
      cursor: pointer;
      user-select: none;
      transition: color 0.2s ease, text-shadow 0.2s ease;
    }

    thead th.sortable:hover {
      color: #d5f6ff;
      text-shadow: 0 0 10px rgba(77, 232, 255, 0.35);
    }

    thead th.sortable::after {
      content: '↕';
      margin-left: 6px;
      color: #6f87b3;
      font-size: 11px;
    }

    thead th.sortable[data-sort-direction="asc"]::after {
      content: '↑';
      color: var(--mint);
    }

    thead th.sortable[data-sort-direction="desc"]::after {
      content: '↓';
      color: var(--cyan);
    }

    tbody td {
      padding: 12px 8px;
      border-bottom: 1px solid rgba(51, 77, 132, 0.5);
      font-size: 16px;
      color: #d7e7ff;
      background: rgba(4, 13, 38, 0.4);
    }

    tbody tr:hover {
      background: rgba(77, 232, 255, 0.09);
    }

    .feature-tags {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      font-size: 11px;
      padding: 3px 9px;
      border-radius: 999px;
      background: rgba(16, 36, 82, 0.82);
      border: 1px solid rgba(166, 125, 255, 0.55);
      color: #cfd6ff;
      font-family: 'JetBrains Mono', monospace;
      box-shadow: 0 0 12px rgba(166, 125, 255, 0.23);
    }

    #scatter {
      width: 100%;
      min-height: 360px;
      border: 1px solid rgba(113, 255, 216, 0.28);
      border-radius: 14px;
      overflow: hidden;
      background: rgba(4, 14, 38, 0.64);
    }

    .legend {
      margin-top: 8px;
      font-size: 12px;
      color: #98b5df;
      font-family: 'JetBrains Mono', monospace;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .chart-note {
      margin: 8px 0 0;
      font-size: 13px;
      color: #8fb5e2;
      font-family: 'JetBrains Mono', monospace;
    }

    .dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
      vertical-align: middle;
    }

    .bars {
      display: grid;
      gap: 10px;
    }

    .bar-row {
      display: grid;
      grid-template-columns: 180px 1fr 120px;
      align-items: center;
      gap: 10px;
    }

    .bar-label {
      font-size: 13px;
      font-weight: 600;
    }

    .bar-track {
      height: 14px;
      background: rgba(9, 27, 68, 0.8);
      border: 1px solid rgba(82, 128, 212, 0.52);
      border-radius: 999px;
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--mint) 0%, var(--cyan) 52%, var(--violet) 100%);
      box-shadow: 0 0 10px rgba(77, 232, 255, 0.55);
    }

    .bar-value {
      font-size: 12px;
      font-family: 'JetBrains Mono', monospace;
      text-align: right;
      color: #9fc2ef;
    }

    @media (max-width: 840px) {
      .hero {
        padding: 24px 20px;
      }

      .manifesto {
        font-size: 18px;
      }

      .maintainer {
        font-size: 17px;
      }

      .stat {
        grid-column: span 12;
      }

      .bar-row {
        grid-template-columns: 1fr;
        gap: 6px;
      }

      .bar-value {
        text-align: left;
      }
    }
  </style>
</head>
<body>
  <main class="shell">
    <section class="hero">
      <span class="label">Production RAG Intelligence</span>
      <h1>RAG Dashboard</h1>
      <p class="manifesto">Production-oriented RAG evaluation stack for retrieval quality, faithfulness, latency, and cost analysis.</p>
      <div class="maintainer">Maintainer: <strong>Gregory Fanous</strong></div>
      <div class="meta" id="meta"></div>
      <div class="topic-tags">
        <span>#MachineLearning</span>
        <span>#AIResearch</span>
        <span>#RAG</span>
      </div>
    </section>

    <section class="grid" id="stats"></section>

    <section class="section card">
      <h2>Leaderboard</h2>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th class="sortable" data-sort-key="strategy_name">Strategy</th>
              <th class="sortable" data-sort-key="feature_signature">Features</th>
              <th class="sortable" data-sort-key="avg_precision_at_k">Precision@k</th>
              <th class="sortable" data-sort-key="avg_recall_at_k">Recall@k</th>
              <th class="sortable" data-sort-key="mrr">MRR</th>
              <th class="sortable" data-sort-key="avg_hallucination_score">Hallucination</th>
              <th class="sortable" data-sort-key="avg_quality_score">Quality</th>
              <th class="sortable" data-sort-key="avg_latency_ms">Latency (ms)</th>
              <th class="sortable" data-sort-key="avg_token_cost_usd">Avg Cost ($)</th>
            </tr>
          </thead>
          <tbody id="leaderboard-body"></tbody>
        </table>
      </div>
    </section>

    <section class="section card">
      <h2>Latency vs Quality Curve</h2>
      <div id="scatter"></div>
      <div class="legend">
        <span><span class="dot" style="background:#a67dff"></span>Method Aggregate Point</span>
        <span><span class="dot" style="background:#71ffd8"></span>Pareto Frontier</span>
      </div>
      <p class="chart-note">Each point is a method average across datasets (not individual dataset runs).</p>
    </section>

    <section class="section card">
      <h2>Token Cost Analysis</h2>
      <div class="bars" id="cost-bars"></div>
    </section>
  </main>

  <script>
    const DATA = {
      benchmark_name: "backend_method_sweep_real_mode",
      run_id: "20260214T072649Z",
      created_at: "2026-02-14T07:26:49Z",
      dataset_path: "/Users/gregoryfanous/WorkspaceJob/RAG_Dashboard/docs/reports/method_sweep_metrics.md",
      strategy_results: [
        { aggregate: { strategy_name: "finder / baseline_fixed", dataset: "finder", method: "baseline_fixed", chunking_strategy: "baseline_fixed", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.2000, avg_recall_at_k: 1.0000, mrr: 1.0000, avg_hallucination_score: 0.4333, avg_latency_ms: 17858.6, avg_quality_score: 0.7350, total_token_cost_usd: 0.29066, avg_token_cost_usd: 0.02907 } },
        { aggregate: { strategy_name: "finder / graphrag_plus", dataset: "finder", method: "graphrag_plus", chunking_strategy: "graphrag_plus", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.1000, avg_recall_at_k: 0.7000, mrr: 0.7000, avg_hallucination_score: 0.4200, avg_latency_ms: 22728.2, avg_quality_score: 0.5320, total_token_cost_usd: 0.39983, avg_token_cost_usd: 0.03998 } },
        { aggregate: { strategy_name: "finder / logicrag_guarded", dataset: "finder", method: "logicrag_guarded", chunking_strategy: "logicrag_guarded", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.0667, avg_recall_at_k: 0.4000, mrr: 0.4000, avg_hallucination_score: 0.8000, avg_latency_ms: 25540.9, avg_quality_score: 0.2867, total_token_cost_usd: 0.48119, avg_token_cost_usd: 0.04812 } },
        { aggregate: { strategy_name: "open_ragbench / baseline_fixed", dataset: "open_ragbench", method: "baseline_fixed", chunking_strategy: "baseline_fixed", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.1800, avg_recall_at_k: 0.9000, mrr: 0.8500, avg_hallucination_score: 0.2000, avg_latency_ms: 10112.8, avg_quality_score: 0.6925, total_token_cost_usd: 0.40746, avg_token_cost_usd: 0.04075 } },
        { aggregate: { strategy_name: "open_ragbench / self_guarded", dataset: "open_ragbench", method: "self_guarded", chunking_strategy: "self_guarded", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.1000, avg_recall_at_k: 0.7000, mrr: 0.7000, avg_hallucination_score: 0.3250, avg_latency_ms: 23705.0, avg_quality_score: 0.5463, total_token_cost_usd: 0.77922, avg_token_cost_usd: 0.07792 } },
        { aggregate: { strategy_name: "open_ragbench / hybrid_dense", dataset: "open_ragbench", method: "hybrid_dense", chunking_strategy: "hybrid_dense", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.1000, avg_recall_at_k: 0.6000, mrr: 0.6000, avg_hallucination_score: 0.1000, avg_latency_ms: 16788.7, avg_quality_score: 0.5200, total_token_cost_usd: 0.51714, avg_token_cost_usd: 0.05171 } },
        { aggregate: { strategy_name: "open_ragbench / graphrag_plus", dataset: "open_ragbench", method: "graphrag_plus", chunking_strategy: "graphrag_plus", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.0857, avg_recall_at_k: 0.6000, mrr: 0.6000, avg_hallucination_score: 0.2000, avg_latency_ms: 17594.0, avg_quality_score: 0.5014, total_token_cost_usd: 0.67003, avg_token_cost_usd: 0.06700 } },
        { aggregate: { strategy_name: "open_ragbench / logicrag_guarded", dataset: "open_ragbench", method: "logicrag_guarded", chunking_strategy: "logicrag_guarded", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.1167, avg_recall_at_k: 0.7000, mrr: 0.6167, avg_hallucination_score: 0.6000, avg_latency_ms: 19061.1, avg_quality_score: 0.4883, total_token_cost_usd: 0.40401, avg_token_cost_usd: 0.04040 } },
        { aggregate: { strategy_name: "public_eval_set / baseline_fixed", dataset: "public_eval_set", method: "baseline_fixed", chunking_strategy: "baseline_fixed", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.2600, avg_recall_at_k: 1.0000, mrr: 1.0000, avg_hallucination_score: 0.0000, avg_latency_ms: 8777.6, avg_quality_score: 0.8150, total_token_cost_usd: 0.09491, avg_token_cost_usd: 0.00949 } },
        { aggregate: { strategy_name: "public_eval_set / logicrag_guarded", dataset: "public_eval_set", method: "logicrag_guarded", chunking_strategy: "logicrag_guarded", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.2000, avg_recall_at_k: 0.9500, mrr: 1.0000, avg_hallucination_score: 0.2556, avg_latency_ms: 11108.4, avg_quality_score: 0.7442, total_token_cost_usd: 0.13641, avg_token_cost_usd: 0.01364 } },
        { aggregate: { strategy_name: "ragcare_qa / self_guarded", dataset: "ragcare_qa", method: "self_guarded", chunking_strategy: "self_guarded", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.1429, avg_recall_at_k: 1.0000, mrr: 1.0000, avg_hallucination_score: 0.3733, avg_latency_ms: 23015.2, avg_quality_score: 0.7297, total_token_cost_usd: 0.34848, avg_token_cost_usd: 0.03485 } },
        { aggregate: { strategy_name: "ragcare_qa / logicrag_guarded", dataset: "ragcare_qa", method: "logicrag_guarded", chunking_strategy: "logicrag_guarded", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.1167, avg_recall_at_k: 0.7000, mrr: 0.7000, avg_hallucination_score: 0.4600, avg_latency_ms: 16463.3, avg_quality_score: 0.5302, total_token_cost_usd: 0.26129, avg_token_cost_usd: 0.02613 } },
        { aggregate: { strategy_name: "retrievalqa / graphrag_plus", dataset: "retrievalqa", method: "graphrag_plus", chunking_strategy: "graphrag_plus", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.3000, avg_recall_at_k: 0.7875, mrr: 0.6083, avg_hallucination_score: 0.0000, avg_latency_ms: 15823.0, avg_quality_score: 0.6527, total_token_cost_usd: 0.34138, avg_token_cost_usd: 0.03414 } },
        { aggregate: { strategy_name: "retrievalqa / self_guarded", dataset: "retrievalqa", method: "self_guarded", chunking_strategy: "self_guarded", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.3000, avg_recall_at_k: 0.7875, mrr: 0.6083, avg_hallucination_score: 0.1000, avg_latency_ms: 18854.2, avg_quality_score: 0.6377, total_token_cost_usd: 0.38906, avg_token_cost_usd: 0.03891 } },
        { aggregate: { strategy_name: "retrievalqa / hybrid_dense", dataset: "retrievalqa", method: "hybrid_dense", chunking_strategy: "hybrid_dense", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.3167, avg_recall_at_k: 0.7208, mrr: 0.5450, avg_hallucination_score: 0.0000, avg_latency_ms: 12786.6, avg_quality_score: 0.6177, total_token_cost_usd: 0.31557, avg_token_cost_usd: 0.03156 } },
        { aggregate: { strategy_name: "retrievalqa / baseline_fixed", dataset: "retrievalqa", method: "baseline_fixed", chunking_strategy: "baseline_fixed", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.3000, avg_recall_at_k: 0.6250, mrr: 0.6283, avg_hallucination_score: 0.0500, avg_latency_ms: 5471.6, avg_quality_score: 0.5933, total_token_cost_usd: 0.17769, avg_token_cost_usd: 0.01777 } },
        { aggregate: { strategy_name: "retrievalqa / logicrag_guarded", dataset: "retrievalqa", method: "logicrag_guarded", chunking_strategy: "logicrag_guarded", recursive_retrieval: false, graph_augmentation: false, hyde: false, self_rag: false, retrieval_k: 0, avg_precision_at_k: 0.1333, avg_recall_at_k: 0.4167, mrr: 0.3200, avg_hallucination_score: 0.6000, avg_latency_ms: 13208.2, avg_quality_score: 0.3192, total_token_cost_usd: 0.15184, avg_token_cost_usd: 0.01518 } }
      ]
    };
    const aggregates = DATA.strategy_results
      .map((item) => item.aggregate)
      .sort((a, b) => b.avg_quality_score - a.avg_quality_score);

    function buildMethodAggregates(rows) {
      const groups = new Map();
      for (const row of rows) {
        const method = row.method || row.chunking_strategy || row.strategy_name;
        if (!groups.has(method)) {
          groups.set(method, {
            method,
            count: 0,
            avg_precision_at_k: 0,
            avg_recall_at_k: 0,
            mrr: 0,
            avg_hallucination_score: 0,
            avg_latency_ms: 0,
            avg_quality_score: 0,
            avg_token_cost_usd: 0,
          });
        }
        const bucket = groups.get(method);
        bucket.count += 1;
        bucket.avg_precision_at_k += row.avg_precision_at_k;
        bucket.avg_recall_at_k += row.avg_recall_at_k;
        bucket.mrr += row.mrr;
        bucket.avg_hallucination_score += row.avg_hallucination_score;
        bucket.avg_latency_ms += row.avg_latency_ms;
        bucket.avg_quality_score += row.avg_quality_score;
        bucket.avg_token_cost_usd += row.avg_token_cost_usd;
      }

      return [...groups.values()]
        .map((bucket) => ({
          strategy_name: bucket.method,
          method: bucket.method,
          source_count: bucket.count,
          avg_precision_at_k: bucket.avg_precision_at_k / bucket.count,
          avg_recall_at_k: bucket.avg_recall_at_k / bucket.count,
          mrr: bucket.mrr / bucket.count,
          avg_hallucination_score: bucket.avg_hallucination_score / bucket.count,
          avg_latency_ms: bucket.avg_latency_ms / bucket.count,
          avg_quality_score: bucket.avg_quality_score / bucket.count,
          avg_token_cost_usd: bucket.avg_token_cost_usd / bucket.count,
        }))
        .sort((a, b) => b.avg_quality_score - a.avg_quality_score);
    }

    const methodAggregates = buildMethodAggregates(aggregates);

    const pct = (value) => `${(value * 100).toFixed(1)}%`;
    const ms = (value) => `${value.toFixed(1)} ms`;
    const usd = (value) => `$${value.toFixed(4)}`;
    const DEFAULT_SORT = { key: 'avg_quality_score', direction: 'desc' };
    let leaderboardSort = { ...DEFAULT_SORT };

    function featureTags(row) {
      const tags = [
        `chunk:${row.chunking_strategy}`,
        row.recursive_retrieval ? 'recursive' : null,
        row.graph_augmentation ? 'graph' : null,
        row.hyde ? 'HyDE' : null,
        row.self_rag ? 'Self-RAG' : null,
      ].filter(Boolean);

      return `<span class="feature-tags">${tags.map((tag) => `<span class="chip">${tag}</span>`).join('')}</span>`;
    }

    function featureSignature(row) {
      return [
        row.chunking_strategy,
        row.recursive_retrieval ? 'recursive' : '',
        row.graph_augmentation ? 'graph' : '',
        row.hyde ? 'hyde' : '',
        row.self_rag ? 'self-rag' : '',
      ].filter(Boolean).join('|');
    }

    function sortValue(row, key) {
      if (key === 'feature_signature') return featureSignature(row);
      return row[key];
    }

    function sortedLeaderboardRows() {
      const rows = [...aggregates];
      rows.sort((a, b) => {
        const left = sortValue(a, leaderboardSort.key);
        const right = sortValue(b, leaderboardSort.key);
        let result = 0;
        if (typeof left === 'number' && typeof right === 'number') {
          result = left - right;
        } else {
          result = String(left).localeCompare(String(right));
        }
        if (result === 0) {
          return a.strategy_name.localeCompare(b.strategy_name);
        }
        return leaderboardSort.direction === 'asc' ? result : -result;
      });
      return rows;
    }

    function renderSortIndicators() {
      const headers = document.querySelectorAll('th.sortable');
      for (const header of headers) {
        const key = header.dataset.sortKey;
        if (key === leaderboardSort.key) {
          header.dataset.sortDirection = leaderboardSort.direction;
          header.setAttribute('aria-sort', leaderboardSort.direction === 'asc' ? 'ascending' : 'descending');
        } else {
          header.dataset.sortDirection = 'none';
          header.setAttribute('aria-sort', 'none');
        }
      }
    }

    function setupLeaderboardSorting() {
      const headers = document.querySelectorAll('th.sortable');
      for (const header of headers) {
        header.addEventListener('click', () => {
          const key = header.dataset.sortKey;
          if (!key) return;
          if (leaderboardSort.key === key) {
            leaderboardSort.direction = leaderboardSort.direction === 'asc' ? 'desc' : 'asc';
          } else {
            leaderboardSort = { key, direction: 'asc' };
          }
          renderLeaderboard();
        });
      }
      renderSortIndicators();
    }

    function renderMeta() {
      const line = `${DATA.benchmark_name} | run ${DATA.run_id} | ${new Date(DATA.created_at).toLocaleString()}`;
      document.getElementById('meta').textContent = line;
    }

    function renderStats() {
      const best = aggregates[0];
      const fastest = [...aggregates].sort((a, b) => a.avg_latency_ms - b.avg_latency_ms)[0];
      const cheapest = [...aggregates].sort((a, b) => a.avg_token_cost_usd - b.avg_token_cost_usd)[0];

      const cards = [
        { label: 'Top Quality Strategy', value: best ? best.strategy_name : 'n/a', sub: best ? pct(best.avg_quality_score) : '-' },
        { label: 'Fastest Strategy', value: fastest ? fastest.strategy_name : 'n/a', sub: fastest ? ms(fastest.avg_latency_ms) : '-' },
        { label: 'Cheapest Per Query', value: cheapest ? cheapest.strategy_name : 'n/a', sub: cheapest ? usd(cheapest.avg_token_cost_usd) : '-' },
      ];

      const html = cards
        .map((card) => `<article class="card stat"><small>${card.label}</small><strong>${card.value}</strong><div>${card.sub}</div></article>`)
        .join('');

      document.getElementById('stats').innerHTML = html;
    }

    function renderLeaderboard() {
      const body = document.getElementById('leaderboard-body');
      const rows = sortedLeaderboardRows();
      body.innerHTML = rows
        .map(
          (row) => `
            <tr>
              <td><strong>${row.strategy_name}</strong></td>
              <td>${featureTags(row)}</td>
              <td>${pct(row.avg_precision_at_k)}</td>
              <td>${pct(row.avg_recall_at_k)}</td>
              <td>${row.mrr.toFixed(3)}</td>
              <td>${pct(row.avg_hallucination_score)}</td>
              <td><strong>${pct(row.avg_quality_score)}</strong></td>
              <td>${ms(row.avg_latency_ms)}</td>
              <td>${usd(row.avg_token_cost_usd)}</td>
            </tr>
          `
        )
        .join('');
      renderSortIndicators();
    }

    function paretoFrontier(rows) {
      const sorted = [...rows].sort((a, b) => a.avg_latency_ms - b.avg_latency_ms);
      const frontier = [];
      let maxQuality = -Infinity;
      for (const row of sorted) {
        if (row.avg_quality_score > maxQuality) {
          frontier.push(row);
          maxQuality = row.avg_quality_score;
        }
      }
      return frontier;
    }

    function drawScatter() {
      const container = document.getElementById('scatter');
      if (!container) return;

      const chartRows = methodAggregates;

      if (!chartRows.length) {
        container.innerHTML = '<div style="padding:22px;color:#9dbde9;font-family:JetBrains Mono, monospace;">No data available for curve.</div>';
        return;
      }

      const width = Math.max(container.clientWidth || 900, 360);
      const height = 360;
      const padding = { top: 20, right: 24, bottom: 54, left: 72 };
      const plotW = Math.max(120, width - padding.left - padding.right);
      const plotH = Math.max(120, height - padding.top - padding.bottom);

      const minLatencyRaw = Math.min(...chartRows.map((row) => row.avg_latency_ms));
      const maxLatencyRaw = Math.max(...chartRows.map((row) => row.avg_latency_ms));
      const minQualityRaw = Math.min(...chartRows.map((row) => row.avg_quality_score));
      const maxQualityRaw = Math.max(...chartRows.map((row) => row.avg_quality_score));

      const latencyPad = Math.max((maxLatencyRaw - minLatencyRaw) * 0.08, 250);
      const qualityPad = Math.max((maxQualityRaw - minQualityRaw) * 0.12, 0.03);

      const minLatency = Math.max(0, minLatencyRaw - latencyPad);
      const maxLatency = maxLatencyRaw + latencyPad;
      const latSpan = Math.max(1, maxLatency - minLatency);

      let minQuality = Math.max(0, minQualityRaw - qualityPad);
      let maxQuality = Math.min(1, maxQualityRaw + qualityPad);
      if (maxQuality - minQuality < 0.05) {
        const mid = (maxQuality + minQuality) / 2;
        minQuality = Math.max(0, mid - 0.03);
        maxQuality = Math.min(1, mid + 0.03);
      }
      const qualSpan = Math.max(0.01, maxQuality - minQuality);

      const x = (lat) => padding.left + ((lat - minLatency) / latSpan) * plotW;
      const y = (quality) => padding.top + (1 - (quality - minQuality) / qualSpan) * plotH;

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', `${height}`);

      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bg.setAttribute('x', '0');
      bg.setAttribute('y', '0');
      bg.setAttribute('width', `${width}`);
      bg.setAttribute('height', `${height}`);
      bg.setAttribute('fill', '#070f2c');
      svg.appendChild(bg);

      const xTicks = 5;
      const yTicks = 5;

      for (let i = 0; i <= yTicks; i += 1) {
        const yVal = padding.top + (plotH * i) / yTicks;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', `${padding.left}`);
        line.setAttribute('x2', `${padding.left + plotW}`);
        line.setAttribute('y1', `${yVal}`);
        line.setAttribute('y2', `${yVal}`);
        line.setAttribute('stroke', '#1e3765');
        line.setAttribute('stroke-width', '1');
        svg.appendChild(line);

        const tickValue = maxQuality - (qualSpan * i) / yTicks;
        const tickLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tickLabel.textContent = pct(tickValue);
        tickLabel.setAttribute('x', `${padding.left - 10}`);
        tickLabel.setAttribute('y', `${yVal + 4}`);
        tickLabel.setAttribute('text-anchor', 'end');
        tickLabel.setAttribute('fill', '#8fb5e2');
        tickLabel.setAttribute('font-size', '11');
        tickLabel.setAttribute('font-family', 'JetBrains Mono, monospace');
        svg.appendChild(tickLabel);
      }

      for (let i = 0; i <= xTicks; i += 1) {
        const xVal = padding.left + (plotW * i) / xTicks;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', `${xVal}`);
        line.setAttribute('x2', `${xVal}`);
        line.setAttribute('y1', `${padding.top}`);
        line.setAttribute('y2', `${padding.top + plotH}`);
        line.setAttribute('stroke', '#16325f');
        line.setAttribute('stroke-width', '1');
        svg.appendChild(line);

        const tickValue = minLatency + (latSpan * i) / xTicks;
        const tickLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tickLabel.textContent = `${Math.round(tickValue).toLocaleString()}`;
        tickLabel.setAttribute('x', `${xVal}`);
        tickLabel.setAttribute('y', `${padding.top + plotH + 16}`);
        tickLabel.setAttribute('text-anchor', 'middle');
        tickLabel.setAttribute('fill', '#8fb5e2');
        tickLabel.setAttribute('font-size', '11');
        tickLabel.setAttribute('font-family', 'JetBrains Mono, monospace');
        svg.appendChild(tickLabel);
      }

      const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      xAxis.setAttribute('x1', `${padding.left}`);
      xAxis.setAttribute('x2', `${padding.left + plotW}`);
      xAxis.setAttribute('y1', `${padding.top + plotH}`);
      xAxis.setAttribute('y2', `${padding.top + plotH}`);
      xAxis.setAttribute('stroke', '#4de8ff');
      xAxis.setAttribute('stroke-width', '1.4');
      svg.appendChild(xAxis);

      const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      yAxis.setAttribute('x1', `${padding.left}`);
      yAxis.setAttribute('x2', `${padding.left}`);
      yAxis.setAttribute('y1', `${padding.top}`);
      yAxis.setAttribute('y2', `${padding.top + plotH}`);
      yAxis.setAttribute('stroke', '#4de8ff');
      yAxis.setAttribute('stroke-width', '1.4');
      svg.appendChild(yAxis);

      const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      xLabel.textContent = 'Average Latency (ms)';
      xLabel.setAttribute('x', `${padding.left + plotW / 2}`);
      xLabel.setAttribute('y', `${height - 8}`);
      xLabel.setAttribute('text-anchor', 'middle');
      xLabel.setAttribute('fill', '#90d8ff');
      xLabel.setAttribute('font-size', '12');
      xLabel.setAttribute('font-family', 'JetBrains Mono, monospace');
      svg.appendChild(xLabel);

      const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      yLabel.textContent = 'Composite Quality Score';
      yLabel.setAttribute('x', '18');
      yLabel.setAttribute('y', `${padding.top + plotH / 2}`);
      yLabel.setAttribute('text-anchor', 'middle');
      yLabel.setAttribute('transform', `rotate(-90 18 ${padding.top + plotH / 2})`);
      yLabel.setAttribute('fill', '#90d8ff');
      yLabel.setAttribute('font-size', '12');
      yLabel.setAttribute('font-family', 'JetBrains Mono, monospace');
      svg.appendChild(yLabel);

      const frontier = paretoFrontier(chartRows);
      if (frontier.length > 1) {
        const points = frontier.map((row) => `${x(row.avg_latency_ms)},${y(row.avg_quality_score)}`).join(' ');
        const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        polyline.setAttribute('points', points);
        polyline.setAttribute('fill', 'none');
        polyline.setAttribute('stroke', '#71ffd8');
        polyline.setAttribute('stroke-width', '2.5');
        svg.appendChild(polyline);
      }

      const showAllLabels = chartRows.length <= 8;
      const topQuality = [...chartRows].sort((a, b) => b.avg_quality_score - a.avg_quality_score)[0];
      const fastest = [...chartRows].sort((a, b) => a.avg_latency_ms - b.avg_latency_ms)[0];
      const labelTargets = new Set(showAllLabels ? chartRows.map((row) => row.strategy_name) : [topQuality?.strategy_name, fastest?.strategy_name].filter(Boolean));

      for (const row of chartRows) {
        const cx = x(row.avg_latency_ms);
        const cy = y(row.avg_quality_score);
        const isTarget = labelTargets.has(row.strategy_name);

        const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        point.setAttribute('cx', `${cx}`);
        point.setAttribute('cy', `${cy}`);
        point.setAttribute('r', isTarget ? '6.5' : '5');
        point.setAttribute('fill', isTarget ? '#71ffd8' : '#a67dff');
        point.setAttribute('stroke', '#efe3ff');
        point.setAttribute('stroke-width', '1');

        const tooltip = document.createElementNS('http://www.w3.org/2000/svg', 'title');
        tooltip.textContent = `${row.strategy_name} | avg quality ${pct(row.avg_quality_score)} | avg latency ${ms(row.avg_latency_ms)} | avg cost ${usd(row.avg_token_cost_usd)} | ${row.source_count} datasets`;
        point.appendChild(tooltip);
        svg.appendChild(point);

        if (isTarget) {
          const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          label.textContent = row.method || row.strategy_name;
          label.setAttribute('x', `${cx + 9}`);
          label.setAttribute('y', `${cy - 9}`);
          label.setAttribute('fill', '#d8f9ff');
          label.setAttribute('font-size', '11');
          label.setAttribute('font-family', 'JetBrains Mono, monospace');
          svg.appendChild(label);
        }
      }

      container.innerHTML = '';
      container.appendChild(svg);
    }

    function renderCostBars() {
      const container = document.getElementById('cost-bars');
      const sorted = [...aggregates].sort((a, b) => b.total_token_cost_usd - a.total_token_cost_usd);
      const maxCost = Math.max(...sorted.map((row) => row.total_token_cost_usd), 1e-9);

      container.innerHTML = sorted
        .map((row) => {
          const width = (row.total_token_cost_usd / maxCost) * 100;
          return `
            <div class="bar-row">
              <div class="bar-label">${row.strategy_name}</div>
              <div class="bar-track"><div class="bar-fill" style="width:${width.toFixed(1)}%"></div></div>
              <div class="bar-value">Total ${usd(row.total_token_cost_usd)}</div>
            </div>
          `;
        })
        .join('');
    }

    renderMeta();
    renderStats();
    setupLeaderboardSorting();
    renderLeaderboard();
    drawScatter();
    renderCostBars();
    window.addEventListener('resize', drawScatter);
  </script>
</body>
</html>
